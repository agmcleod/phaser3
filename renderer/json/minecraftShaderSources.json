{
"comment": [
        "// Minecraft Shader. Created by Reinder Nijhoff 2013",
        "// @reindernijhoff",
        "//",
        "// https://www.shadertoy.com/view/4ds3WS",
        "//",
        "// port of javascript minecraft: http://jsfiddle.net/uzMPU/",
        "// original code by Markus Persson: https://twitter.com/notch/status/275331530040160256",
        "// combined with voxel-shader by inigo quilez (https://www.shadertoy.com/view/4dfGzs)",
        "//",
        "// All credit goes to inigo quilez!",
        "//"
    ],

"fragment": [
        "precision mediump float;",
        
        "#define SEALEVEL -25.",
        "#define MAXSTEPS 256",
        "#define CAMERA_SCREEN 2.5",
        "#define SUN_POWER 0.4",
        "#define SUN_SIZE 18.0",
        "#define SKY_COLOUR vec3(0.35,0.47,0.60)",
        "//#define HOUSE",

        "#define MAT_GRASS 1",
        "#define MAT_DIRT 2",
        "#define MAT_STONE 4",
        "#define MAT_HOUSE 5",
        "#define MAT_ROOF 6",
		"#define MAT_TRUNK 7",
		"#define MAT_LEAVES 8",
        "#define MAT_WATER 9",
        "#define MAT_CLOUD 10",

        "uniform vec3 uCameraPos;",
        "uniform vec3 uCameraLookAt;",
        "uniform sampler2D uImageSampler;",
        
        "vec3 sundir = normalize( vec3(-0.5,0.6,0.7) );",
        "vec2 iResolution = vec2(1.0, 1.0);",

        "float hash( in float n ) {",
        "    return fract(sin(n)*43758.5453123);",
        "}",
        "float hash( in vec3 x ) {",
        "    float n = dot( x, vec3(1.0,113.0,257.0) );",
        "    return fract(sin(n)*43758.5453123);",
        "}",
        "vec3 hash3( vec3 n ) {",
        "    return fract(sin(n)*vec3(653.5453123,4456.14123,165.340423));",
        "}",
        "float sum(vec3 v) { return dot(v, vec3(1.0)); }",

        "// port of minecraft",

        "void getMaterialColor( int i, vec2 coord, out vec3 color ) {",
        "    // 16x16 texture coordinates",
        "    vec2 uv = floor( coord );",

        "    // get hash value for stippling and variation",
        "    float h = hash(uv.x + uv.y*347.0 + 4321.0 * float(i));",
                
       	"    // stippling for grass, water, leaves, dirt",
        "    float br = 1. - h * (96./255.);",

        "    // dirt colour",
        "    color = vec3( 128./255., 64./255., 48./255.);",

        "    if (i == MAT_GRASS) {",
        "        // make jaggy edge for hanging grass",
        "        float xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);",
        "        if ( uv.y < (xm1 + 18.)) {",
        "            // top and grass hanging over edge into top of dirt below",
        "            color = vec3( 96./255., 196./255., 64./255.);",
        "        } else if (uv.y < (xm1 + 19.)) {",
        "            // dark shadow underneath hanging grass edge",
        "            br *= .36;",
        "        } else if (uv.y < (xm1 + 21.)) {",
        "            // light shadow underneath hanging grass edge",
        "            br *= .66;",
        "        }",
        "    }",

        "    if (i == MAT_STONE) {",
        "        color = vec3( 96./255., 96./255., 104./255.);",
        "    }",

        "#ifdef HOUSE",
        "    if (i == MAT_HOUSE) {",
        "        color = vec3( 181./255.,  58./255.,  21./255.); // 0xB53A15;",
        "        if ( mod(uv.x + (floor(uv.y / 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {",
        "            color = vec3( 188./255., 175./255., 165./255.); // 0xBCAFA5;",
        "        }",
        "    }",
        "#endif",

        "    if (i == MAT_TRUNK) {",
        "        color = vec3( 103./255., 82./255.,  49./255.); // 0x675231;",
        "        if ( h < 0.5 ) {",
        "            // vertical lines in the stippling to suggest bark strips",
        "            br = br * (3.0 - mod(uv.x, 3.));",
        "        }",
        "    }",

        "    if (i == MAT_LEAVES) {",
        "        if ( h < 0.7) {",
	    "            color = vec3(  32./255., 128./255., 32./255.);",
        "        }",
        "        else {",
	    "            color = vec3(  8./255., 64./255.,  8./255.);",
        "        }",
        "    }",

        "    if (i == MAT_WATER) {",
        "        // water",
        "        color = vec3(  64./255.,  64./255., 255./255.); // 0x4040ff;",
        "    }",

        "    if (i == MAT_CLOUD) {",
        "        color = vec3(0.65,0.68,0.7)*1.35;",
        "        br = 1.;",
        "    }",
        "    color *= br;",
        
        "    return;",
        "}",

        "//=====================================================================",
        "// Code by inigo quilez - iq/2013:",

        "const mat3 m = mat3( 0.00,  0.80,  0.60,",
        "                    -0.80,  0.36, -0.48,",
        "                    -0.60, -0.48,  0.64 );",

        "float mapTerrain( vec2 p ) {",
        "    float f;",
        "    f = texture2D( uImageSampler, fract(p * 0.0002) ).r;",
        "    return max(f * 50.0 + SEALEVEL, SEALEVEL);",
        "}",

        "//vec3 globalRayOrigin = vec3(0.0);",

        "bool map(in vec3 c ) {",

        "    vec3 p = c + 0.5;",
        
        "    vec2 fc = floor( c.xz * 0.05 );",
        "    vec3 h = hash3( vec3( fc*vec2(213.123,2134.125), mapTerrain(fc) ) );",
        "    bool hit = false;",

        "    if ( h.z > 0.75 ) {",
        "        vec2 tp = floor( fc * 20. + mod( h.yx * 154.43125, 10. ) ) + 5.5;",
        "        float h = mapTerrain( tp );",
        "        if ( h > SEALEVEL ) {",
        "            if ( all( equal( tp, p.xz ) ) ) hit = c.y < h+4.; // treetrunk",
        "            if ( distance( p, vec3( tp.x, h+6., tp.y ) ) < 2.5 ) hit = true; // leaves",
        "        }",
        "    }",

        "    float f = mapTerrain( p.xz );",
        "    hit = c.y < f ? true:hit; // ground",

        "    //if ( c.y > 8. && sin( (c.y - 8.) * (3.1415 / 32.) ) * ( 10./(c.y-7.) ) > 0.6 )",
        "    //    hit = true; // clouds",

        "#ifdef HOUSE",
        "    vec2 hc = abs(c.xz - vec2( 32., 130.)); // house",
        "    if ( all( lessThan( hc, vec2( 6., 10. ) ) ) && c.y < -hc.x-12. ) {",
        "        hit = true;",
        "        if ( all( lessThan( hc, vec2( 2., 10. ) ) ) && c.y < -18. && c.y > -23. ) {",
        "            hit = false;",
        "        }",
        "        if ( all( lessThan( hc, vec2( 5., 9. ) ) ) && c.y < -18. && c.y > -23. ) {",
        "            hit = false;",
        "        }",
        "    }",
        "#endif",

        "    return hit;",
        "}",


        "int mapMaterial(in vec3 c ) {",
        "    int mat = 0;",
        "    vec3 p = c + 0.5;",

        "    float f = ceil( mapTerrain( p.xz ) );",

        "    if ( p.y <= f ) mat = MAT_GRASS;",
        "    else if ( p.y < f+3. ) mat = MAT_TRUNK;",
        "    else if ( p.y < f+10. ) mat = MAT_LEAVES;",
        "    else mat = MAT_CLOUD;",

        "#ifdef HOUSE",
        "    vec2 hc = abs(c.xz - vec2( 32., 130.));",
        "    if ( c.y < 0. && all( lessThan( hc, vec2( 6., 10. ) ) ) ) {",
        "        mat = MAT_HOUSE;",
        "        if ( !map( c+vec3(0.,1.,0.) ) ) mat = MAT_ROOF;",
        "    }",
        "#endif",

        "    return mat;",
        "}",

        "// oVos and oDir are NOT used if return == 0, faster exit from castRay if no collision",
        "float castRay( in vec3 rayOrigin, in vec3 rayDir, out vec3 oVos, out vec3 oDir ) {",
        "    vec3 pos = floor(rayOrigin);",
        "    vec3 ri = 1.0 / rayDir;",
        "    vec3 rs = sign(rayDir);",
        "    vec3 dis = (pos - rayOrigin + 0.5 + rs * 0.5) * ri;",
        "    vec3 rsi = rs * ri;",
        "    vec3 moveMask = vec3(0.0);",
        "    for( int i=0; i<MAXSTEPS; i++ )",
        "    {",
        "        // which axis to move? (the largest one)",
        "        moveMask = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);",
        "        dis += moveMask * rsi;",
        "        pos += moveMask * rs;",
        "        if ( map(pos) ) {",
        "            // intersect the cube",
        "            vec3 mini = (pos - rayOrigin + 0.5 - 0.5 * vec3(rs)) * ri;",
        "            float t = max ( mini.x, max ( mini.y, mini.z ) );",
        "            oDir = moveMask;",
        "            oVos = pos;",
        "            return t;",
        "        }",
        "    }",
        "    return 0.;",
        "}",

        "float castVRay( in vec3 rayOrigin, in vec3 rayDir, in float maxDist ) {",

        "    vec3 pos = floor(rayOrigin);",
        "    vec3 ri = 1.0/rayDir;",
        "    vec3 rs = sign(rayDir);",
        "    vec3 dis = (pos-rayOrigin + 0.5 + rs*0.5) * ri;",
        "    float res = 1.0;",
        "    for( int i=0; i<18; i++ )",
        "    {",
        "        if ( map(pos) ) { return 0.; }",
        "        vec3 moveMask = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);",
        "        dis += moveMask * rs * ri;",
        "        pos += moveMask * rs;",
        "    }",
        "    return res;",
        "}",


        "//=====================================================================",
        "// Ambient occlusion",

        "vec4 edges( in vec3 vos, in vec3 nor, in vec3 dir )",
        "{",
        "    vec3 v1 = vos + nor + dir.yzx;",
        "    vec3 v2 = vos + nor - dir.yzx;",
        "    vec3 v3 = vos + nor + dir.zxy;",
        "    vec3 v4 = vos + nor - dir.zxy;",

        "    vec4 res = vec4(0.0);",
        "    if ( map(v1) ) res.x = 1.0;",
        "    if ( map(v2) ) res.y = 1.0;",
        "    if ( map(v3) ) res.z = 1.0;",
        "    if ( map(v4) ) res.w = 1.0;",

        "    return res;",
        "}",

        "vec4 corners( in vec3 vos, in vec3 nor, in vec3 dir )",
        "{",
        "    vec3 v1 = vos + nor + dir.yzx + dir.zxy;",
        "    vec3 v2 = vos + nor - dir.yzx + dir.zxy;",
        "    vec3 v3 = vos + nor - dir.yzx - dir.zxy;",
        "    vec3 v4 = vos + nor + dir.yzx - dir.zxy;",

        "    vec4 res = vec4(0.0);",
        "    if ( map(v1) ) res.x = 1.0;",
        "    if ( map(v2) ) res.y = 1.0;",
        "    if ( map(v3) ) res.z = 1.0;",
        "    if ( map(v4) ) res.w = 1.0;",

        "    return res;",
        "}",

        "varying vec2 v_texcoord;",
        
        "void main() {",
        "    // convert texture coordinate into range -1..+1 in x and y directions",
        "    vec2 q = v_texcoord.xy / iResolution.xy;",
        "    vec2 p = -1.0 + 2.0*q;",
        "    // adjust for aspect ratio of the texture",
        "    p.x *= iResolution.x / iResolution.y;",

        "    // camera",
        "    float cameraBank = 0.0;",
        "    vec3 rayOrigin = uCameraPos;",
        "    vec3 target = uCameraLookAt;",
        "    //target.y = rayOrigin.y;",
        "    //globalRayOrigin = rayOrigin;",

        "    // build ray",
        "    vec3 ww = normalize(target - rayOrigin);",
        "    vec3 uu = normalize(cross( vec3(sin(cameraBank),cos(cameraBank),0.0), ww ));",
        "    vec3 vv = normalize(cross(ww,uu));",
        "    vec3 rayDir = normalize(p.x*uu + p.y*vv + CAMERA_SCREEN*ww);",

        "    // lighting for the sky",
        "    float sun = clamp(dot(sundir,rayDir), 0., 1.);",
        "    // azimuth",
        "    float azi = exp(rayDir.y) - 1.0;",
        "    vec3 col = clamp(SKY_COLOUR + vec3(-azi * 0.2, -azi * 0.2, azi * 0.6), 0., 1.);",
        "    col = clamp(col + SUN_POWER * vec3(1.0, 1.0, 0.0) * pow( sun, SUN_SIZE ), 0., 1.);",

        "    // vos and dir are NOT used if t == 0, faster exit from castRay if no collision",
        "    vec3 vos, dir;",
        "    float t = castRay( rayOrigin, rayDir, vos, dir );",

        "    if ( t > 0. ) {",
        "        vec3 nor = -dir * sign(rayDir);",
        "        vec3 pos = rayOrigin + rayDir*t;",
        "        int mMat = mapMaterial( vos );",

        "        if ( mMat == 1 ) {",
        "            if ( map( vos + vec3(0., 1., 0. ) ) ) {",
        "                mMat = hash(vos) > 0.5 ? MAT_DIRT : MAT_STONE;",
        "                if ( map( vos + vec3(0., 2., 0. ) ) ) mMat = MAT_STONE;",
        "            }",
        "            if ( vos.y < SEALEVEL ) mMat = MAT_WATER;",
        "        }",

        "        vec3 mCol;",
        "        vec3 mpos = mod( pos * 16., 16. );",
        "        // use normal of the cube face to determine where the texture comes from",
        "        vec2 textureCoord = (nor.y != 0.) ? mpos.xz : (nor.x != 0.) ? -mpos.zy + vec2(32., 32.) : -mpos.xy + vec2(32., 32.);",
        "        getMaterialColor( mMat, textureCoord, mCol );",

        "        // cube face catches the suns rays?",
        "        float dif = clamp( dot( nor, sundir ), 0.0, 1.0 );",
        "        float sha = 0.0;",
        "        if ( dif > 0.01 ) sha = castVRay( pos + nor * 0.01, sundir, 32.0 );",
        "        float bac = clamp( dot( nor, normalize(sundir*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );",
        "        float sky = 0.5 + 0.5*nor.y;",
        "        float amb = 1.0;",

        "        // ambient occlusion",

        "        vec4 ed = edges( vos, nor, dir );",
        "        vec4 co = corners( vos, nor, dir );",
        "        vec3 uvw = pos - vos;",
        "        vec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );",

        "        float occ = 0.0;",
        "        // (for edges)",
        "        occ += (    uv.x) * ed.x;",
        "        occ += (1.0-uv.x) * ed.y;",
        "        occ += (    uv.y) * ed.z;",
        "        occ += (1.0-uv.y) * ed.w;",
        "        // (for corners)",
        "        occ += (      uv.y *     uv.x ) * co.x*(1.0-ed.x)*(1.0-ed.z);",
        "        occ += (      uv.y *(1.0-uv.x)) * co.y*(1.0-ed.z)*(1.0-ed.y);",
        "        occ += ( (1.0-uv.y)*(1.0-uv.x)) * co.z*(1.0-ed.y)*(1.0-ed.w);",
        "        occ += ( (1.0-uv.y)*     uv.x ) * co.w*(1.0-ed.w)*(1.0-ed.x);",
        "        occ = 1.0 - occ/8.0;",
        "        occ = occ*occ;",
        "        occ = occ*occ;",
        
        "        vec3 lin = vec3(0.0);",
        "        lin += 4.0*dif*vec3(1.)*(0.5+0.5*occ)*(0.25+0.75*sha);",
        "        lin += 1.8*bac*vec3(1.0,0.5,1.0)*(0.5+0.5*occ);",
        "        lin += 4.0*sky*vec3(0.4,0.51,0.85)*occ;",

        "        if ( mMat == 10 ) {",
        "            col = mix( col, mCol*lin*0.6, 0.3);",
        "        } else {",
        "            // atmospheric",
        "            col = mCol*lin*0.2;",
        "            //col = mix( mCol*lin*0.2, col, 1.0-exp(-0.0000000*t*t*t) );",
        "        }",
        "    }",

        "    // sepia lighting when looking into the sun",
        "    //col += 0.2 * vec3(1.0,0.4,0.2) * pow( sun, 3.0 );",

        "    // gamma",
        "    col = pow( col, vec3(0.45) );",

        "    // contrast",
        "    col = col* 0.25 + 0.75*col*col*(3.0-2.0*col);",
        "    col = clamp( col, 0.0, 1.0 );",

        "    // vignetting",
        "    //col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );",

        "    gl_FragColor = vec4( col, 1.0 );",
        "}"

    ],
    
"vertex": [
        " attribute vec4 aPosition;",
        " varying vec2 v_texcoord;",
        " void main() {",
        "   gl_Position = aPosition;",
        "   v_texcoord = aPosition.xy * 0.5 + 0.5;",
        " }"
    ],
    
"attributes":
    [ "aPosition" ],
"uniforms":
    [ "uCameraPos", "uCameraLookAt" ],
"samplers":
    [ "uImageSampler" ]
}