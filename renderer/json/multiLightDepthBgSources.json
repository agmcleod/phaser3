{
	"comment": [
		"// for all pixels on screen",
		"//   if pixel is not covered by wall in the walls texture",
		"//     for all light sources",
		"//       scan from the pixel to each light source",
		"//       if any scan location is blocked by wall abort scan immediately",
		"//       else accumulate colour based on the light source and distance",
		"//     end for",
		"//     set pixel to the floor texture pixel multiplied by the accumulated light colour",
		"//   else",
		"//     we're in a wall, so set the pixel from the walls texture",
		"// end for"
		],

	"fragment": [
		" precision highp float;",
		" ",
		" // fixed maximum number of lights in the scene",
		" #define MAX_LIGHTS 16",
		" // STEPS controls the granularity of the shadow edges, smaller numbers = more blocky",
		" #define STEPS 32.0",
		" // FLOOR_DIMMER and WALL_DIMMER affect the brightness of those tiles directly",
		" // FLOOR_LIGHT_DIMMER && WALL_LIGHT_DIMMER affect the brightness of the lighting glow on those tiles",
		" #define FLOOR_DIMMER vec4(0.2, 0.2, 0.2, 1.0)",
		" #define FLOOR_LIGHT_DIMMER vec4(1.0, 1.0, 1.0, 1.0)",
		" #define WALL_DIMMER vec4(0.5, 0.5, 0.5, 1.0)",
		" #define WALL_LIGHT_DIMMER vec4(0.10, 0.10, 0.10, 1.0)",
		" ",
		" varying mediump vec2 v_texcoord;",
		" uniform sampler2D uImageSampler;",
		" uniform sampler2D uFloorSampler;",
		" uniform sampler2D uDepthSampler;",
		" uniform vec4 uLights[MAX_LIGHTS];",
		" ",
		" // the lighting power is a float containing r,g,b packed as four bits each",
		" vec3 unpack(float val)",
		" {",
		"   vec3 col;",
		"   col.b = floor(val / 256. / 256.);",
		"   col.g = floor((val - col.b * 256. * 256.) / 256.);",
		"   col.r = floor(val - col.b * 256. * 256. - col.g * 256.);",
		"   return col / 16.;",
		" }",
		" ",
		" // is there a wall here?",
		" bool blocked(vec2 p)",
		" {",
		"   return ( texture2D(uImageSampler, p).rgb != vec3(0.0, 0.0, 0.0) );",
		" }",
		" ",
		" // what colour is the floor or wall here?",
		" vec4 getColor(vec2 p)",
		" {",
		"   vec4 col = texture2D(uImageSampler, p);",
		"   if ( col.rgb != vec3(0.0, 0.0, 0.0) )",
		"     return col;",
		"   vec2 ip = vec2(p.x, 1.0 - p.y);",
		"   return texture2D(uFloorSampler, ip);",
		" }",
		" ",
		" // depth mapping, use the uDepthSampler texture to provide slope information",
		" float getBright(vec2 p, vec2 lp, float invDist)",
		" {",
		"    float ret = 0.0;",
		" ",
		"    vec2 px = vec2(mod(p.x * 800., 32.), mod((1.0 - p.y) * 600., 32.));",
		"    px /= 32.;",
		"    vec4 slope = texture2D(uDepthSampler, px);",
		"    slope.xy -= 0.5;",
		"    ",
		" ",
		"    vec2 off = lp - p;",
		"    if (abs(slope.x) <= 0.1)",
		"      ret += 0.5 * invDist;",
		"    else {",
		"      if (off.x < 0. && slope.x < 0.) ret += abs(slope.x) * invDist;",
		"      if (off.x > 0. && slope.x > 0.) ret += abs(slope.x) * invDist;",
		"    }",
		"    if (abs(slope.y) <= 0.1)",
		"      ret += 0.5 * invDist;",
		"    else {",
		"      if (off.y > 0. && slope.y < 0.) ret += abs(slope.y) * invDist;",
		"      if (off.y < 0. && slope.y > 0.) ret += abs(slope.y) * invDist;",
		"    }",
		"    ",
		"    return ret;",
		" }",
		" ",
		" vec4 getLight(vec2 p, vec2 lp, float power, float range, bool inWall)",
		" {",
		"   bool ignoreWall = inWall;",
		"   float d = distance(lp, p) / range;",
		"   if (d >= 1.0)",
		"     return vec4(0.);",
		"   vec2 sp = p;",
		"   vec2 step = (lp - p) / STEPS;",
		"   for(float i = 0.0; i < 1.0; i += 1.0 / STEPS)",
		"   {",
		"     if ( blocked(sp) )",
		"     {",
		"       if (!ignoreWall)",
		"         return vec4(0.);",
		"     }",
		"     else",
		"       ignoreWall = false;",
		"     sp += step;",
		"   }",
		"   //float id = 1. - d;",
		"   vec4 pow = vec4(unpack(power), 0.0);",
		"   float od = d * 3. + .3;",
		"   if (inWall)",
		"     return pow * (.09 / (od * od * od)) * WALL_LIGHT_DIMMER;",
		"   return pow * (.09 / (od * od)) * getBright(p, lp, 1. - d) * FLOOR_LIGHT_DIMMER;",
		" }",
		" ",
		" vec4 getLighting(vec2 p)",
		" {",
		"   vec4 light = vec4(0.);",
		"   for(int i = 0; i < MAX_LIGHTS; i++)",
		"   {",
		"     vec4 data = uLights[i];",
		"     if (data.z > 0.)",
		"       light += getLight(p, data.xy, data.z, data.w, false);",
		"   }",
		"   return light;",
		" }",
		" ",
		" vec4 lightOnWall(vec2 p)",
		" {",
		"   vec4 light = vec4(0.);",
		"   for(int i = 0; i < MAX_LIGHTS; i++)",
		"   {",
		"     vec4 data = uLights[i];",
		"     if (data.z > 0.)",
		"       light += getLight(p, data.xy, data.z, data.w, true);",
		"   }",
		"   return light;",
		" }",
		" ",
		" ",
		" void main() {",
		"   if ( blocked(v_texcoord.xy) )",
		"     gl_FragColor = texture2D(uImageSampler, v_texcoord.xy) * WALL_DIMMER + lightOnWall(v_texcoord.xy);",
		"   else",
		"     gl_FragColor = getColor(v_texcoord.xy) * FLOOR_DIMMER + getLighting(v_texcoord.xy);",
		" }" 
		],

	"vertex": [
    	" attribute vec4 aPosition;",
    	" varying vec2 v_texcoord;",
		" void main() {",
		"   gl_Position = aPosition;",
		"   v_texcoord = aPosition.xy * 0.5 + 0.5;",
		" }"
		],

	"attributes":
		[ "aPosition" ],

	"uniforms":
		[ "uLights" ],

	"samplers":
		[ "uImageSampler", "uFloorSampler", "uDepthSampler" ]
}
